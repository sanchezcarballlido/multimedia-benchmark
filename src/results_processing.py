# src/results_processing.py
import os
import pandas as pd
import xml.etree.ElementTree as ET
import subprocess
import json
import re
from itertools import combinations
from . import bdr_calculator

def _get_bitrate_from_file(file_path):
    """
    Extracts the bitrate from a media file using ffprobe.
    Returns bitrate in kbps, or None if an error occurs.
    """
    if not os.path.exists(file_path):
        print(f"Warning: File not found at {file_path}. Cannot get bitrate.")
        return None

    try:
        # Command to get stream information in JSON format for easy parsing
        command = (
            f"ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate "
            f"-of json \"{file_path}\""
        )
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        
        # Parse the JSON output and extract bitrate
        data = json.loads(result.stdout)
        if 'streams' in data and len(data['streams']) > 0 and 'bit_rate' in data['streams'][0]:
            bitrate_bps = float(data['streams'][0]['bit_rate'])
            return bitrate_bps / 1000  # Convert bps to kbps
        else:
            print(f"Warning: Bitrate not found in ffprobe output for {file_path}.")
            return None

    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"Warning: Could not get bitrate for {file_path} using ffprobe. "
              f"Is FFmpeg installed and in your PATH? Error: {e}")
        return None
    except (KeyError, IndexError, json.JSONDecodeError):
        print(f"Warning: Could not parse bitrate from ffprobe output for {file_path}.")
        return None

def _extract_vmaf_from_xml(xml_path):
    """
    Parses the final VMAF score from the XML log file generated by FFmpeg.
    """
    if not os.path.exists(xml_path):
        print(f"Warning: VMAF log not found at {xml_path}.")
        return None
        
    try:
        tree = ET.parse(xml_path)
        # The final score is typically a pooled metric. This is more specific.
        vmaf_score = tree.find('.//metric[@name="vmaf"]').attrib['mean']
        return float(vmaf_score)
    except (ET.ParseError, FileNotFoundError, AttributeError, KeyError):
        print(f"Warning: Could not parse VMAF score from {xml_path}.")
        return None

def _extract_cpu_time_from_log(log_path):
    """
    Parses the output of `/usr/bin/time -v` to get total CPU time.
    Total CPU time is the sum of user time and system time.
    """
    if not os.path.exists(log_path):
        print(f"Warning: Time log not found at {log_path}.")
        return None
    
    user_time = None
    sys_time = None
    try:
        with open(log_path, 'r') as f:
            for line in f:
                if 'User time (seconds):' in line:
                    user_time = float(line.split(':')[1].strip())
                elif 'System time (seconds):' in line:
                    sys_time = float(line.split(':')[1].strip())
        
        if user_time is not None and sys_time is not None:
            return user_time + sys_time
        else:
            print(f"Warning: Could not find User or System time in {log_path}.")
            return None
            
    except (IOError, IndexError, ValueError) as e:
        print(f"Warning: Could not parse CPU time from {log_path}. Error: {e}")
        return None


def process_results(results_dir):
    """
    Walks through the results directory, compiles the data, and calculates BD-Rates
    using two approaches: pairwise comparison and single-anchor comparison.
    """
    all_data = []
    print(f"üîç Starting to process results in: {results_dir}")
    
    # A more robust regex to capture all your presets
    all_presets = ["ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo"]
    preset_pattern = r'_(' + '|'.join(all_presets) + ')$'

    for root, _, files in os.walk(results_dir):
        for file in files:
            if file.endswith("_encoding.log"):
                parts = root.replace(results_dir, '').strip(os.sep).split(os.sep)
                if len(parts) < 4:
                    print(f"Warning: Skipping unexpected directory structure: {root}")
                    continue
                
                base_name = file.replace("_encoding.log", "")
                preset_match = re.search(preset_pattern, base_name)
                
                if not preset_match:
                    continue
                
                preset = preset_match.group(1)
                video_name = re.sub(preset_pattern, '', base_name)

                log_path = os.path.join(root, file)
                encoded_file_path = log_path.replace("_encoding.log", ".mp4")
                vmaf_log_path = log_path.replace("_encoding.log", "_vmaf.log")
                time_log_path = log_path.replace("_encoding.log", "_time.log")

                print(f"  - Processing: {video_name} | Codec: {parts[0]} | CRF: {parts[1]} | Preset: {preset}")

                bitrate = _get_bitrate_from_file(encoded_file_path)
                vmaf_score = _extract_vmaf_from_xml(vmaf_log_path)
                cpu_time = _extract_cpu_time_from_log(time_log_path)
                
                data = {
                    'codec': parts[0], 'crf': int(parts[1]), 'resolution': parts[2],
                    'video_name': video_name, 'preset': preset, 'bitrate_kbps': bitrate,
                    'vmaf': vmaf_score, 'cpu_time_seconds': cpu_time
                }
                all_data.append(data)
    
    if not all_data:
        print("‚ö†Ô∏è Warning: No data was processed.")
        return

    df = pd.DataFrame(all_data).sort_values(by=['video_name', 'codec', 'crf']).reset_index(drop=True)
    output_csv_path = os.path.join(results_dir, "combined_data.csv")
    df.to_csv(output_csv_path, index=False)
    print(f"\n‚úÖ Successfully created combined results file at: {output_csv_path}")

    # --- Approach 1: Pairwise BD-Rate Calculation (Existing) ---
    _calculate_pairwise_bd_rate(df, results_dir)

    # --- Approach 2: Single-Anchor BD-Rate Calculation (New) ---
    _calculate_single_anchor_bd_rate(df, results_dir)


def _calculate_pairwise_bd_rate(df, results_dir):
    """Calculates BD-Rate for all codec pairs within the same preset."""
    unique_codecs = df['codec'].unique()
    if len(unique_codecs) < 2:
        return

    print("\nüìä Calculating pairwise BD-Rates...")
    bd_rate_results = []
    for (video_name, preset), group_df in df.groupby(['video_name', 'preset']):
        for anchor_codec, test_codec in combinations(unique_codecs, 2):
            for anchor, test in [(anchor_codec, test_codec), (test_codec, anchor_codec)]:
                bd_rate = bdr_calculator.calculate_bd_rate(group_df, anchor, test, 'vmaf')
                if bd_rate is not None:
                    bd_rate_results.append({
                        'video_name': video_name, 'preset': preset,
                        'anchor_codec': anchor, 'test_codec': test,
                        'bd_rate_vmaf_%': bd_rate
                    })
    
    if bd_rate_results:
        bd_rate_df = pd.DataFrame(bd_rate_results)
        output_path = os.path.join(results_dir, "bd_rate_results.csv")
        bd_rate_df.to_csv(output_path, index=False)
        print(f"‚úÖ Successfully created pairwise BD-Rate results file at: {output_path}")

def _calculate_single_anchor_bd_rate(df, results_dir):
    """Calculates BD-Rate for all configurations against one fixed anchor."""
    ANCHOR_CODEC = 'libx264'
    ANCHOR_PRESET = 'medium'
    
    print(f"\nüìä Calculating BD-Rates against single anchor ({ANCHOR_CODEC} @ {ANCHOR_PRESET})...")
    bd_rate_anchor_results = []
    
    test_points = df[['codec', 'preset']].drop_duplicates().to_records(index=False)
    
    for (video_name,), group_df in df.groupby(['video_name']):
        for test_codec, test_preset in test_points:
            if test_codec == ANCHOR_CODEC and test_preset == ANCHOR_PRESET:
                continue
                
            bd_rate = bdr_calculator.calculate_bd_rate_for_presets(
                group_df,
                anchor_codec=ANCHOR_CODEC, anchor_preset=ANCHOR_PRESET,
                test_codec=test_codec, test_preset=test_preset,
                metric='vmaf'
            )
            
            if bd_rate is not None:
                bd_rate_anchor_results.append({
                    'video_name': video_name,
                    'anchor': f"{ANCHOR_CODEC}@{ANCHOR_PRESET}",
                    'test': f"{test_codec}@{test_preset}",
                    'bd_rate_vmaf_%': bd_rate
                })

    if bd_rate_anchor_results:
        bd_rate_anchor_df = pd.DataFrame(bd_rate_anchor_results)
        output_path = os.path.join(results_dir, "bd_rate_anchor_results.csv")
        bd_rate_anchor_df.to_csv(output_path, index=False)
        print(f"‚úÖ Successfully created single-anchor BD-Rate results at: {output_path}")
    else:
        print(f"‚ö†Ô∏è Warning: Could not calculate any single-anchor BD-Rates. "
              f"Ensure the anchor ({ANCHOR_CODEC}@{ANCHOR_PRESET}) has valid data.")
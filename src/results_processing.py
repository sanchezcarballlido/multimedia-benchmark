# src/results_processing.py
import os
import pandas as pd
import xml.etree.ElementTree as ET
import subprocess
import json
import re

def _get_bitrate_from_file(file_path):
    """
    Extracts the bitrate from a media file using ffprobe.
    Returns bitrate in kbps, or None if an error occurs.
    """
    if not os.path.exists(file_path):
        print(f"Warning: File not found at {file_path}. Cannot get bitrate.")
        return None

    try:
        # Command to get stream information in JSON format for easy parsing
        command = (
            f"ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate "
            f"-of json \"{file_path}\""
        )
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        
        # Parse the JSON output and extract bitrate
        data = json.loads(result.stdout)
        if 'streams' in data and len(data['streams']) > 0 and 'bit_rate' in data['streams'][0]:
            bitrate_bps = float(data['streams'][0]['bit_rate'])
            return bitrate_bps / 1000  # Convert bps to kbps
        else:
            print(f"Warning: Bitrate not found in ffprobe output for {file_path}.")
            return None

    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"Warning: Could not get bitrate for {file_path} using ffprobe. "
              f"Is FFmpeg installed and in your PATH? Error: {e}")
        return None
    except (KeyError, IndexError, json.JSONDecodeError):
        print(f"Warning: Could not parse bitrate from ffprobe output for {file_path}.")
        return None

def _extract_vmaf_from_xml(xml_path):
    """
    Parses the final VMAF score from the XML log file generated by FFmpeg.
    """
    if not os.path.exists(xml_path):
        print(f"Warning: VMAF log not found at {xml_path}.")
        return None
        
    try:
        tree = ET.parse(xml_path)
        # The final score is typically a pooled metric. This is more specific.
        vmaf_score = tree.find('.//metric[@name="vmaf"]').attrib['mean']
        return float(vmaf_score)
    except (ET.ParseError, FileNotFoundError, AttributeError, KeyError):
        print(f"Warning: Could not parse VMAF score from {xml_path}.")
        return None

def _extract_cpu_time_from_log(log_path):
    """
    Parses the output of `/usr/bin/time -v` to get total CPU time.
    Total CPU time is the sum of user time and system time.
    """
    if not os.path.exists(log_path):
        print(f"Warning: Time log not found at {log_path}.")
        return None
    
    user_time = None
    sys_time = None
    try:
        with open(log_path, 'r') as f:
            for line in f:
                if 'User time (seconds):' in line:
                    user_time = float(line.split(':')[1].strip())
                elif 'System time (seconds):' in line:
                    sys_time = float(line.split(':')[1].strip())
        
        if user_time is not None and sys_time is not None:
            return user_time + sys_time
        else:
            print(f"Warning: Could not find User or System time in {log_path}.")
            return None
            
    except (IOError, IndexError, ValueError) as e:
        print(f"Warning: Could not parse CPU time from {log_path}. Error: {e}")
        return None


def process_results(results_dir):
    """
    Walks through the results directory, parses logs and media files,
    and compiles the data into a single CSV file.
    """
    all_data = []
    print(f"üîç Starting to process results in: {results_dir}")
    
    for root, _, files in os.walk(results_dir):
        for file in files:
            # Use the encoding log as the primary indicator of a completed task
            if file.endswith("_encoding.log"):
                # --- Extract info from directory/filename ---
                parts = root.replace(results_dir, '').strip(os.sep).split(os.sep)
                if len(parts) < 3:
                    print(f"Warning: Skipping unexpected directory structure: {root}")
                    continue
                
                # Robustly get preset, assuming it's the last part of the filename
                base_name = file.replace("_encoding.log", "")
                preset = base_name.split('_')[-1]
                video_name = '_'.join(base_name.split('_')[:-1])

                # --- Define paths for all files ---
                log_path = os.path.join(root, file)
                encoded_file_path = log_path.replace("_encoding.log", ".mp4")
                vmaf_log_path = log_path.replace("_encoding.log", "_vmaf.log")
                time_log_path = log_path.replace("_encoding.log", "_time.log")

                print(f"  - Processing: {video_name} | Codec: {parts[0]} | CRF: {parts[1]} | Preset: {preset}")

                # --- Extract metrics ---
                bitrate = _get_bitrate_from_file(encoded_file_path)
                vmaf_score = _extract_vmaf_from_xml(vmaf_log_path)
                cpu_time = _extract_cpu_time_from_log(time_log_path)
                
                # --- Assemble data record ---
                data = {
                    'codec': parts[0],
                    'crf': int(parts[1]),
                    'resolution': parts[2],
                    'video_name': video_name,
                    'preset': preset,
                    'bitrate_kbps': bitrate,
                    'vmaf': vmaf_score,
                    'cpu_time_seconds': cpu_time
                }
                all_data.append(data)
    
    if not all_data:
        print("‚ö†Ô∏è Warning: No data was processed. Check the results directory for log files.")
        return

    # Convert to DataFrame, sort, and save
    df = pd.DataFrame(all_data)
    df = df.sort_values(by=['video_name', 'codec', 'crf']).reset_index(drop=True)
    
    output_csv_path = os.path.join(results_dir, "combined_data.csv")
    df.to_csv(output_csv_path, index=False)
    
    print(f"\n‚úÖ Successfully created combined results file at: {output_csv_path}")
    print("--- CSV Head ---")
    print(df.head().to_string())
    print("----------------")